# -*- coding: utf-8 -*-
"""Estatística1_Frequencias_Medidas_Aula.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zeUJAEKjU5mqNEQV2KnAQU9xIKsSugYe

### ESTATÍSTICA 1: **FREQUENCIAS E MEDIDAS**
"""

### bibliotecas base
import pandas as pd
import numpy as np
### bibliotecas para visualizacao de dados
import seaborn as sns
import matplotlib.pyplot as plt
### bibliotecas para estatística
import scipy.stats as stat

"""## Leitura dos dados"""

!pip install pydataset --quiet ## instala a biblioteca
from pydataset import data ### biblioteca q contem diferentes datasets

"""Vamos primeiramente ler a documentação do dataset em que iremos utilizar"""

data('Forbes2000', show_doc = True)

### leitura do dataset frobes que contém os dados
forbes = data('Forbes2000')

forbes.head() ### leitura das 5 primeiras linhas do dataset

"""### Tipos de variáveis"""

forbes.info() ### verificando quais colunas sao numéricas e quais categóricas.

"""No caso acima, as colunas denotadas por "object" sao categóricas, as colunas int64 assumem valores inteiros e as colunas float64 sao numéricas contínuas

# Análise de tendencia central

Moda: aplicada em todas as variáveis do dataframe

- utilizar a funcao df.mode()
- No caso vamos retirar as 2 primeiras colunas pois elas assumem valores unicos, sao identificadores
"""

forbes.iloc[:, 2:8].mode()

"""Média e mediana (somente para variáveis numéricas)"""

forbes[['sales', 'profits', 'assets', 'marketvalue']].mean()

forbes[['sales', 'profits', 'assets', 'marketvalue']].median()

"""A funcao describe acima calcula estatísticas descritivas das variáveis numéricas"""

forbes.describe()

"""Nesse caso temos a média e a mediana representada pelo percentil 50%

# Analise de dispersão e outliers

Para a análise de dispersão iremos calcular:
1. Amplitude, desvio padrao e variancia
2. Analisar os histogramas das variaveis
3. Construir o boxplot
4. Verificar outliers

### 1. Amplitude, desvio padrão e variância
"""

### essa funcao: adiciona no describe anterior as colunas de amplitude e variancia.
### a amplitude será o máximo - minimo valor
### a variancia será o desvio padrão ao quadrado
def describe_new(df):
    df1 = df.describe()
    df1.loc["amplitude"] = df1.loc['max'] - df1.loc['min']
    df1.loc["variancia"] = df1.loc['std']*df1.loc['std']
    return df1

describe_new(forbes)

"""A maior amplitude ou discrepancia das empresas listadas na forbes 2000 é relacionada aos ativos da empresa, os assets, conforme podemos ver. Essa também é a variavel com maior desvio padrão .(nao iremos considerar a variável ranking, pois nesse caso ela seria como o nosso ID da empresa)

### Histograma das variáveis
"""

plt.rcParams['figure.figsize'] = [8, 10]
sns.set_theme()
# create distplots
for column in forbes.select_dtypes(include=np.number).columns:
    plt.figure()
    sns.displot(data = forbes , x = column, kde= True)
    plt.title("Histograma: "+column)

"""### Boxplot das variáveis"""

plt.rcParams['figure.figsize'] = [8, 4]
sns.set_theme()
### para cada uma das colunas numericas roda o boxplot
for column in forbes.select_dtypes(include=np.number).columns:
    plt.figure()
    sns.boxplot(data = forbes , x = column, color='cyan',showfliers=True)
    plt.title("Boxplot: "+column + " in billion USD")

"""Nota-se a grande quantidade de outliers expressadas pelos pontinhos nos gráficos de caixa, o que dificultou bastante a visualizacao dos dados

Para fazermos os boxplots sem considerar os outliers podemos rodar a mesma funçao porem com o parametro showfliers = False, assim ficará mais facil a analise dos resultados
"""

plt.rcParams['figure.figsize'] = [8, 4]
sns.set_theme()

for column in forbes.select_dtypes(include=np.number).columns: ### filtrando o plot somente para variaveis numericas
    plt.figure()
    sns.boxplot(data = forbes , x = column, color='cyan',showfliers=False)
    plt.title("Boxplot: "+column + " in billion USD")

"""Pelos box plots podemos ver a grande concentracao de empresas com:
- Vendas proximas a 2-9 bilhoes
- Lucro oscilando proximo a 0 (0.1 a 0.5 bilhoes) com valores positivos e negativos nas caldas,
- Asssets (ativos) de 5 a 25 bilhoes
- Valor de mercado proximo a 3 - 11 bilhoes

Vamos agora analisar os outliers encontrados!!

### Outliers das variáveis

#### 1. Metodo do Z score:
O método z-score utiliza como referencia a quantos desvios padrões a informação está da média

 Se Z-score > 3  desvios padroes geralmente se pode considerar um outlier.
"""

import pandas as pd
import numpy as np
from scipy import stats ### pacote de estatística que contem a funcao z-score

def find_outlier_zscore(dataset, threshold, colname):
  ### funcao que calcula a quantidade de outliers encontrados dado o nome do dataframe, o threshold e o nome da coluna
    df = dataset[colname]
    outliers = []
    zscore = []
    threshold = threshold
    mean = np.mean(df)
    std = np.std(df)
    for i in df.values:
      z_score= (i - mean)/std
      zscore.append(z_score)
      if np.abs(z_score) > threshold:
          outliers.append(i)
    print("o número de outliers encontrado em {} foi de: ".format(colname),len(outliers))
    return zscore, outliers

for column in forbes.select_dtypes(include=np.number).columns:
  zscore, out =  find_outlier_zscore(forbes, 3, column)
  if len(out) > 0:
    plt.figure(figsize = (10,5))
    sns.displot(zscore)
    plt.axvspan(xmin = 3 ,xmax= max(zscore),alpha=0.2, color='red')
    plt.title("Outliers detectados em {}".format(column))

"""pelo grafico acima fica mais facil visualizar os valores outliers para cada nivel de z-score.

Vemos que para z-score = 3, valores considerados outliers estao nas caldas dos histogramas , em vermelho

#### Removendo outliers com o método z-score
1. Replace outliers with mean
"""

def replace_na_outlier_zscore(dataset, threshold, colname):
  ### funcao que faz um replace para NaN (valor nulo) caso seja encontrado um outlier
    df = dataset[colname]
    outliers = []
    zscore = []
    val = []
    threshold = threshold
    mean = np.mean(df)
    std = np.std(df)
    for i in df.values:
      z_score= (i - mean)/std
      zscore.append(z_score)
      if np.abs(z_score) > threshold:
          outliers.append(i)
          val.append(np.nan)
      else:
          val.append(i)

    return val

def drop_outliers(dataset, threshold):
  ### vamos utilizar a funcao drop NA para remover outliers
  for column in dataset.select_dtypes(include=np.number).columns:
    dataset[column] =  replace_na_outlier_zscore(dataset, 3, column)
  return dataset.dropna()

def replace_median_outliers(dataset, threshold):
  ### vamos utilizar a funcao fillna para trocar os NaNs pela mediana
  for column in dataset.select_dtypes(include=np.number).columns:
    dataset[column] =  replace_na_outlier_zscore(dataset, 3, column)
  return dataset.fillna(dataset.median())

forbes_zscore_na = drop_outliers(forbes, 3)

forbes_zscore_median = replace_median_outliers(forbes, 3)

"""#### 2. Metodo do IQR :
O método IQR (distância inter-quartil em inglês) ve a distancia da amplitude dos quartis:
"""

forbes = data('Forbes2000')

def find_outlier_iqr(dataset, colname):
    q25, q75 = np.quantile(dataset[colname], 0.25), np.quantile(dataset[colname], 0.75)
    # calcula  IQR
    iqr = q75 - q25
    # calcula outlier cutoff
    cut_off = iqr * 1.5
    # calcula margens inferiores, lower e superiores upper
    lower, upper = q25 - cut_off, q75 + cut_off
    print(' IQR é ',iqr)
   # print('Valor minimo', lower)
   # print('Valor maximo', upper)
    outliers = []

    for i in dataset[colname].values:
      if((i > upper)or(i < lower)):
        outliers.append(i)
    print('O numero de outliers encontrado foi de', len(outliers))
    return lower, upper, outliers

for column in forbes.select_dtypes(include=np.number).columns:
  lower, upper, out =  find_outlier_iqr(forbes, column)
  if (len(out) > 0):
    plt.figure(figsize = (10,6))
    sns.displot(forbes[column], kde=False)
    plt.axvspan(xmin = lower,xmax= forbes[column].min(),alpha=0.2, color='red')
    plt.axvspan(xmin = upper,xmax= forbes[column].max(),alpha=0.2, color='red')
    plt.title("Outliers detectados em {}".format(column))

"""# Análise de Missing Values (dados faltantes)

1. Vamos verificar a soma de dados faltandes para dada uma das colunas do dataframe:
"""

forbes.isna().sum()

import missingno as msno ### pacote com visualizacoes de dados faltantes

msno.matrix(forbes) ## essa visualizacao nos da uma ideia da completude dos dados faltantes

"""atençao: isna() é o mesmo que isnull(), no pandas

"""

### vamos construir uma tabela com o % de valores faltantes de cada variável abaixo

missing = forbes.isna().sum()

missing_perc = 100 * forbes.isna().sum() / len(forbes)

mis_val_table = pd.concat([missing, missing_perc], axis=1)

mis_val_table = mis_val_table.rename(columns = {0 : '# Count: valores nulos', 1 : '% do Total'})

mis_val_table = mis_val_table[mis_val_table.iloc[:,1] != 0].sort_values(
        '% do Total', ascending=False).round(1)

print ("O dataframe contém " + str(forbes.shape[1]) + " colunas.\n"
            "Contendo " + str(mis_val_table.shape[0]) +
              " colunas com valores faltantes.")

mis_val_table

"""# EDA AUTOMATIZADA

Existem 2 pacotes famosos no mundo da analise de dados que fazem analises exploratorias automatizadas:
1. Pandas profiling -> chamado atualmente de ydataprofiling
2. Sweetviz

Ambas geram relatorios html prontos para analises / interpretacoes do analista
"""

!pip install sweetviz --quiet

import sweetviz as sv

my_report = sv.analyze(forbes) ### le os dados e cria uma report

my_report.show_notebook() ### para ver o html no notebook

my_report.show_html(  filepath='./SWEETVIZ_REPORT.html',
            open_browser=True,
            layout='widescreen',
            scale=None)
#### gera o html e salva no seu diretorio local